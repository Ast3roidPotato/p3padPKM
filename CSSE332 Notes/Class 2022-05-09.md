### More Garbage Collection

```toc
```
^TOC

#### Simple tracing garbage collection

Periodically or when memory is low...

1. Pause the eecution of out language
2. Start with a set of pointers that we call the "roots"
	1. These are cariales that are definitely accessible
	2. Includes the stacks of all threads
	3. Includes globals
3. For each accessile object
	1. Finds all objects that are accessible through the object's fields
	2. mark these objects as accessible
	3. Add these objects tothe list o objects to be searched
4. When this is done, free any unmarked objects

<span style='color:green'>PROS: </span>
- Never Frees something accessible
- Always frees everything unused
- No trouble with circular references

Cons
- Basically have to visit the entire memory space - SLOW
- Program is paused while this is happening
- Memory is fragmented

This is why languages like Java are subject to random long pauses.

This method is still used because it reduces bugs, and oftentimes, the cost of an increased runtime of a program is worth less than the cost of paying someone to fix more bugs.

#### Compacting GC
Seems inefficient - more efficient in the long run

 1. Copy known accessable objects via a memory traversal similar to that of the tracing GC, update all references
	 - Re-writing the memory pointers isn't as bad when you are in the middle of a traversal than otherwise.
 2. Free the old memory space.

Allocation and deallocation isn't super expensive, but it isn't free.

Deallocation: 
OS call -> lookup memory in page table -> mark page as invalid

Cost of a system call. 

You generally want to avoid system calls as much as possible because it's likely that you'll lose the rest of your CPU slot.

Malloc and free attempt to reuse memory space by trying to fill up the OS allocated pages as much as possible before making an OS system call to allocate more memory,

Malloc and free are sophisticated functions that do alot of work that would be complicated to do manually.

