### More Paging

```toc
```
^TOC

#### Page Fault
If a page is not present in physical memory, then the hardware triggers a page fault.

If the page fault is caused by the program, the OS might give it a seg fault, or kill it.

If the page fault is because the process tries to use memory the that OS was supposed to allocate but didn't, the OS will then fix it's error by actually allocating what it was supposed to, then re-running the assembly code that failed the first time. This means that the OS can actually allocate more memory than there is in the system, and as long as the actual memory used by the processes is less than the total memory, there's no problem.

If a process tries to use memory that it thinks it allocated, but wasn't actually allocated by the OS, AND the physical memory is full, the OS will go take another frame in memory, write it to disk, then use the newly freed frame to shove the page into. The process is unaware of anything going on other than an increased amount of time taking to read/write to memory.

#### Swapping Policy: Optimal

Goal: minimize the amount of misses, and evit pages tha twill be access the futhest in the future.

^^ This is hard to do, so replacement policies are used instead.

###### Practical

The OS doesn't keep track of what pages are used
As such, any page replacement algorithms that keep track of what pages are used must be done on silicon.
- FIFO - Bad because it doesn't consider the importance of the page
- 

